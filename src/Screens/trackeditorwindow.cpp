#include "trackeditorwindow.h"
#include "../QTUiFiles/ui_trackeditorwindow.h"
#include "../chordselector.h"


#include <iostream>
#include <QtWidgets>

/**
 * @brief Constructor for the TrackEditorWindow class.
 *
 * Initializes a new instance of the TrackEditorWindow, a QMainWindow for editing music tracks.
 * Sets up the user interface using the generated Ui::TrackEditorWindow class.
 * Creates and configures user interface elements, such as an initial button and a ChordSelector.
 *
 * @param parent The parent widget of the TrackEditorWindow, if it has one.
 */
TrackEditorWindow::TrackEditorWindow(QWidget *parent)
    : QMainWindow(parent),
    ui(new Ui::TrackEditorWindow)
{
    ui->setupUi(this);
    QSize size = qApp->screens()[0]->size();

    QPushButton* initialButton = new QPushButton(QString("+"), this);
    initialButton->move(size.width()/128, size.width()/24);
    initialButton->setVisible(true);

    ChordSelector* chordSelector = new ChordSelector(this);
    chordSelector->setParent(this);

    //dewiniaeth fathemategol ardderchog
    chordSelector->setFixedSize(size.width()/3 - size.width()/20, size.height()/2);
    chordSelector->move(2*(size.width()/3) + size.width()/48, size.height()/16);

    connect(initialButton, &QPushButton::clicked, this, &TrackEditorWindow::showNewComponentPicker);
}

TrackEditorWindow::~TrackEditorWindow()
{
    delete ui;
}

/**
 * @brief Destructor for the TrackEditorWindow class.
 *
 * Cleans up resources associated with the TrackEditorWindow instance.
 * Deletes the user interface generated by the Ui::TrackEditorWindow class.
 * This destructor is automatically called when the TrackEditorWindow is being destroyed.
 */
void TrackEditorWindow::on_actionQuit_triggered()
{
    //Check save state etc

    QCoreApplication::quit();
}

void TrackEditorWindow::on_actionSave_As_triggered()
{
    saveToFile();
}

void TrackEditorWindow::saveToFile()
{
    QString fileName = QFileDialog::getSaveFileName(this,
                                                    tr("Save Track"),
                                                    "",
                                                    tr("Track (*.tr);;All Files (*)"));

    if (fileName.isEmpty())
        return;
    else {
        QFile file(fileName);
        if (!file.open(QIODevice::WriteOnly)) {
            QMessageBox::information(this, tr("Unable to open file"),
                                     file.errorString());
            return;
        }

        QDataStream out(&file);
        out.setVersion(QDataStream::Qt_4_5);

        for (QWidget* component : findChildren<QWidget*>()) {
            if (auto* serializableComponent = dynamic_cast<ISerializable*>(component)) {
                serializableComponent->serialize(out);
            }
        }

        QMessageBox::information(this, tr("Save Successful"),
                                 tr("Track saved successfully."));
    }
}
/**
 * @brief Displays a dialog for selecting a new music track component and creates it based on user choice.
 *
 * Shows a modal dialog (NewComponentPicker) to allow the user to choose a type of music track component.
 * Based on the user's selection, a corresponding component factory is created (LyricsComponentCreator,
 * ChordsComponentCreator, or NotebookComponentCreator).
 * The selected factory is then used to create a new instance of the chosen component, and it is added
 * to the TrackEditorWindow using the createComponent function.
 */
void TrackEditorWindow::showNewComponentPicker()
{
    static NewComponentPicker newComponentPicker(this);
    newComponentPicker.setModal(true);

    if (newComponentPicker.exec() == QDialog::Accepted) {
        QString selectedComponentType = newComponentPicker.getSelectedComponentType();

        std::unique_ptr<ComponentFactory> factory;

        if (selectedComponentType == "Lyrics") {
            factory = std::make_unique<LyricsComponentCreator>();
        } else if (selectedComponentType == "Chords") {
            factory = std::make_unique<ChordsComponentCreator>();
        } else if (selectedComponentType == "Notebook") {
            factory = std::make_unique<NotebookComponentCreator>();
        }

        if (factory) {
            QWidget* componentToUse = factory->CreateComponent();
            createComponent(componentToUse, selectedComponentType);
        }
    }
}

/**
 * @brief Creates and displays a new music track component in the TrackEditorWindow.
 *
 * Sets the fixed size of the provided component and adjusts its position.
 * Hides the triggering button and shows the created component at the adjusted position.
 * Creates a new button below the component to allow adding more components of the same type.
 *
 * @param componentToUse A pointer to the QWidget representing the music track component to be created.
 * @see TrackEditorWindow::showNewComponentPicker
 */
void TrackEditorWindow::createComponent(QWidget* componentToUse, QString selectedComponentType)
{
    if (!componentToUse) {
        std::cerr << "Invalid component." << std::endl;
        return;
    }

    this->componentToUse = componentToUse;

    QSize size = qApp->screens()[0]->size();
    componentToUse->setFixedSize(2*(size.width()/3), 32);
    auto button = qobject_cast<QPushButton*>(sender());

    if (button) {
        auto buttonPos = button->pos();
        button->hide();
        componentToUse->move(buttonPos.x(), buttonPos.y() + size.height()/128);
        componentToUse->setParent(this);
        componentToUse->show();
        QPushButton* newButton = new QPushButton(QString("+"), this);
        newButton->move(buttonPos.x(), buttonPos.y() + size.height()/20);
        newButton->setVisible(true);

        connect(newButton, &QPushButton::clicked, this, &TrackEditorWindow::showNewComponentPicker);
    }
}

